# -*- coding: utf-8 -*-
"""Copy of Welcome To Colaboratory

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Q3HPBgD7U3JDpDs6vCMzFL6G_odAZO-U
"""

from google.colab import drive
drive.mount('/content/drive')

import tensorflow as tf
from tensorflow.keras import layers
import numpy as np
import torch
from tensorflow import keras
import os
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'
from tensorflow.keras import Input , Model
from tensorflow.keras.layers import Conv1D , MaxPooling1D , Flatten , Dense , UpSampling1D , Reshape ,AveragePooling1D, UpSampling1D

model=torch.load('/content/drive/MyDrive/eeg_signals_128_sequential_band_all_with_mean_std.pth')
data= np.array(model['dataset'])

train_size = 9572
test_size = 2393
x_train = []
y_train = []

x_test = []
y_test = []

#training data preparation
for i in range(train_size):
  h = tf.make_ndarray(tf.make_tensor_proto(data[i]['eeg']))
  x_train.append(h)
  y_train.append((data[i]['label']))
y_train = np.array(y_train)

#training data resize
#temp = np.zeros(shape=(train_size,128,460))
temp = np.empty([train_size, 128, 440])
for i in range(train_size):
  for j in range(128):
     temp[i][j] = list(x_train[i][j][40:480])
x_train = temp
del temp

for i in range(test_size):
  h = tf.make_ndarray(tf.make_tensor_proto(data[i+train_size]['eeg']))
  x_test.append(h)
  y_test.append(data[i+train_size]['label'])
y_test = np.array(y_test)
#testing data resize
temp = np.zeros(shape=(test_size,128,440))
for i in range(test_size):
  for j in range(128):
     temp[i][j] = list(x_test[i][j][40:480])
x_test = temp
del temp
del data

print(type(x_train),x_train.shape)
print(type(y_train),y_train.shape)
print(type(x_test),x_test.shape)
print(type(y_test),y_test.shape)

input_sig = Input(shape=(128,440)) 
x = Conv1D(64,3, activation='relu', padding='valid',data_format='channels_first')(input_sig)
x_ = MaxPooling1D(2,data_format='channels_first')(x)
x1 = Conv1D(32,3, activation='relu', padding='valid',data_format='channels_first')(x_)
x1_ = MaxPooling1D(2,data_format='channels_first')(x1)
#x2 = Conv1D(64,3, activation='relu', padding='valid',data_format='channels_first')(x1_)
#x2_ = MaxPooling1D(2,data_format='channels_first')(x2)
flat = Flatten()(x1_)
dense = Dense(64,activation = 'relu')(flat)
encoded = Dense(40,activation = 'softmax')(dense)
autoencoder = Model(input_sig, encoded)
autoencoder.compile(optimizer='adam', loss='mse', metrics=['accuracy'])

autoencoder.summary()

autoencoder.fit(x_train, y_train, epochs=100, verbose=1, validation_data=(x_test, y_test),batch_size=128)